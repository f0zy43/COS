========ПРОЕКТ 1: lr41===============================================================================
=====================================================================================================

library IEEE;
· Подключение стандартной библиотеки IEEE - как набор базовых инструментов для работы с цифровыми схемами

use IEEE.STD_LOGIC_1164.ALL;
· Использование пакета STD_LOGIC_1164 - основные типы данных для работы с битами и векторами

use IEEE.STD_LOGIC_ARITH.ALL;
· Пакет для арифметических операций - сложение, вычитание с сигналами

use IEEE.STD_LOGIC_UNSIGNED.ALL;
· Пакет для работы с беззнаковыми числами - рассматриваем сигналы как положительные числа

entity lr41 is
· Объявление модуля с именем lr41 - создаем "черный ящик" с входами и выходами

 port(
  KEY: in STD_LOGIC;
  BUZZER: out STD_LOGIC
  );
· Описание портов:
  · KEY: in STD_LOGIC - одна входная кнопка (1 бит)
  · BUZZER: out STD_LOGIC - один выход для зуммера (1 бит)

end lr41;
· Конец описания модуля

architecture arch_lr41 of lr41 is
· Начало архитектуры - описание того, КАК работает модуль

begin
· Начало исполняемого кода

 process(KEY)
· Создание процесса, чувствительного к кнопке KEY - процесс запускается при изменении KEY

 begin
· Начало кода процесса

  case KEY is
· Оператор CASE (выбор) - проверяет значение сигнала KEY

   when '0' => BUZZER <= '0';
· Когда KEY = '0' (кнопка нажата) → включаем зуммер (BUZZER = '0')
· Предполагается, что кнопка активна низким уровнем (0=нажата) и зуммер тоже активен низким уровнем

   when others => BUZZER <= '1';
· Во всех остальных случаях (когда KEY = '1' - кнопка отпущена) → выключаем зуммер

  end case;
· Конец оператора выбора

 end process;
· Конец процесса

end arch_lr41;
· Конец архитектуры

Что делает программа: Когда нажимаем кнопку KEY - зуммер пищит, когда отпускаем - перестает.

========ПРОЕКТ 2: lr42===============================================================================
=====================================================================================================

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
· Подключение только основных пакетов - арифметика не нужна

entity lr42 is
port(
    KEY: in STD_LOGIC_VECTOR(2 downto 0); 
    SEG: out STD_LOGIC_VECTOR(7 downto 0);
    DIG: out STD_LOGIC_VECTOR(3 downto 0)
);
end lr42;
· Порты:
  · KEY: in STD_LOGIC_VECTOR(2 downto 0) - 3 кнопки (биты 2,1,0)
  · SEG: out STD_LOGIC_VECTOR(7 downto 0) - 8 сигналов для сегментов индикатора (7 сегментов + точка)
  · DIG: out STD_LOGIC_VECTOR(3 downto 0) - 4 сигнала для выбора разряда (какой из 4 цифр светить)

architecture arch_lr42 of lr42 is
· Начало архитектуры

    function key_to_seg(key: std_logic_vector(2 downto 0)) return std_logic_vector is
· Объявление ФУНКЦИИ с именем key_to_seg
· Принимает вектор из 3 бит (код кнопки)
· Возвращает вектор из 8 бит (код для сегментов)

    begin
· Начало кода функции

        case key is
· Проверяем значение входного вектора key

            when "000" => return "00111111"; -- 0
· Если все кнопки отпущены (000) - показываем цифру 0
· "00111111" - код для цифры 0 на 7-сегментном индикаторе

            when "100" => return "00000110"; -- 1
· Если нажата кнопка 2 (100) - показываем цифру 1

            when "010" => return "01011011"; -- 2
· Если нажата кнопка 1 (010) - показываем цифру 2

            when "001" => return "01001111"; -- 3
· Если нажата кнопка 0 (001) - показываем цифру 3

            when "011" => return "01110111"; -- A
· Если нажаты кнопки 0 и 1 (011) - показываем букву A

            when "101" => return "01111100"; -- B
· Если нажаты кнопки 0 и 2 (101) - показываем букву B

            when "110" => return "00111001"; -- C
· Если нажаты кнопки 1 и 2 (110) - показываем букву C

            when others => return "01110001"; -- Все сегменты выключены
· Для всех остальных комбинаций - выключаем сегменты

        end case;
· Конец выбора
end function;
· Конец функции

begin
· Начало основного кода

    DIG <= "1110";  -- Активируем только первый разряд индикатора
· Выбор разряда индикатора: "1110" означает что активен только первый разряд (крайний правый)
· Обычно 0 = активен, 1 = неактивен

    SEG <= key_to_seg(KEY); -- Преобразуем код клавиши в сегментный код
· Вызываем функцию key_to_seg и передаем ей состояние кнопок KEY
· Результат функции выводим на сегменты индикатора

end arch_lr42;
· Конец архитектуры

Что делает программа: В зависимости от комбинации нажатых кнопок показывает на 7-сегментном индикаторе разные цифры и буквы.

========ПРОЕКТ 3: lr43===============================================================================
=====================================================================================================

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
· NUMERIC_STD.ALL - пакет для работы с числами (более современный чем ARITH)

entity lr43 is
  Port(
    clk: in STD_LOGIC; 
    SEG: out STD_LOGIC_VECTOR(7 downto 0);
    DIG: out STD_LOGIC_VECTOR(3 downto 0)
  );
end lr43;
· Порты:
  · clk: in STD_LOGIC - тактовый сигнал (метроном)
  · SEG, DIG - как в предыдущем проекте

architecture arch_lr43 of lr43 is
· Начало архитектуры

  signal counter: integer range 0 to 9 := 0;
· Счетчик от 0 до 9 - цифра, которая показывается на индикаторе

  signal slow_clock: std_logic := '0';
· Медленный тактовый сигнал - для мигания (1 раз в секунду)

  signal freq_counter: integer range 0 to 50000000 := 0;
· Счетчик для деления частоты - считает тактовые импульсы чтобы создать медленный сигнал

  function digit_to_seg(digit: integer; dp: std_logic) return std_logic_vector is
· Функция преобразования цифры в код сегментов
· digit - цифра от 0 до 9
· dp - точка (decimal point)

    variable seg7: std_logic_vector(6 downto 0);
· Временная переменная для хранения кода 7 сегментов (без точки)

  begin
· Начало кода функции

    case digit is
· Выбор в зависимости от цифры

      when 0 => seg7 := "0111111"; 
· Для цифры 0 - код сегментов "0111111"
· Внимание! Здесь используется нестандартная кодировка

      when 1 => seg7 := "0000110";
· Для цифры 1

      when 2 => seg7 := "1011011";
      when 3 => seg7 := "1001111";
      when 4 => seg7 := "1100110";
      when 5 => seg7 := "1101101";
      when 6 => seg7 := "1111101";
      when 7 => seg7 := "0000111";
      when 8 => seg7 := "1111111";
      when 9 => seg7 := "1101111";
· Коды для остальных цифр

      when others => seg7 := "0000000";
· Для недопустимых цифр - все сегменты выключены

    end case;
· Конец выбора

    return not dp & seg7; -- точка + сегменты
· Формируем итоговый 8-битный код:
  · not dp - инвертированная точка (старший бит)
  · & - оператор конкатенации (склеивания)
  · seg7 - 7 младших битов для сегментов

  end function;
· Конец функции

begin
· Начало основного кода

  process(clk)
· Процесс для деления частоты - создает медленный сигнал из быстрого тактового

  begin
    if rising_edge(clk) then
· На каждом переднем фронте тактового сигнала

      if freq_counter < 50000000 then
        freq_counter <= freq_counter + 1;
· Если счетчик не достиг 50 миллионов - увеличиваем его

      else
        freq_counter <= 0;
        slow_clock <= not slow_clock;
· Иначе (достигли 50 млн) - сбрасываем счетчик и переключаем медленный сигнал
· При 50 МГц тактовой частоты это дает 1 Гц (1 раз в секунду)

      end if;
    end if;
  end process;
· Конец процесса деления частоты

  process(slow_clock)
· Процесс для основного счетчика - работает от медленного сигнала

  begin
    if rising_edge(slow_clock) then
· Раз в секунду (на фронте slow_clock)

      if counter < 9 then
        counter <= counter + 1;
· Если счетчик меньше 9 - увеличиваем на 1

      else
        counter <= 0;
· Иначе (достиг 9) - сбрасываем в 0

      end if;
    end if;
  end process;
· Конец процесса счетчика

  DIG <= "1110";  -- Активируем только первый разряд
· Включаем только первый разряд индикатора

  SEG <= digit_to_seg(counter, '0');
· Преобразуем счетчик в код сегментов
· counter - текущая цифра (0-9)
· '0' - точка выключена

end arch_lr43;
· Конец архитектуры

Что делает программа: Создает счетчик который каждую секунду увеличивается от 0 до 9 и показывает текущую цифру на 7-сегментном индикаторе.

Важное замечание о кодировке сегментов:

В разных проектах используются разные кодировки для 7-сегментного индикатора. Обычно:

· '1' = сегмент горит, '0' = не горит (активный высокий уровень)
· Или '0' = сегмент горит, '1' = не горит (активный низкий уровень)