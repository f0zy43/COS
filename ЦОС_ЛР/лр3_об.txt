========ПРОЕКТ 1: lr31===============================================================================
=====================================================================================================

library IEEE;
· Библиотека IEEE - это как большая коллекция готовых инструментов для работы с цифровыми схемами. Представьте, что это как набор стандартных деталей для конструктора.

use IEEE.STD_LOGIC_1164.ALL;
· Берем из библиотеки пакет STD_LOGIC_1164 - это основной набор типов данных. Например, здесь определены "STD_LOGIC" (один бит) и "STD_LOGIC_VECTOR" (несколько битов вместе).

use IEEE.STD_LOGIC_ARITH.ALL;
· Берем пакет STD_LOGIC_ARITH - это инструменты для арифметических операций (сложение, вычитание и т.д.) с нашими битами.

use IEEE.STD_LOGIC_UNSIGNED.ALL;
· Берем пакет STD_LOGIC_UNSIGNED - это дополнительный инструмент, который говорит: "работай с нашими числами как с положительными" (без знака).

entity lr31 is
· Создаем сущность (модуль) с именем lr31 - это как объявление "черного ящика". Мы говорим: "будет такая штука под названием lr31, у нее есть вот такие входы и выходы".

  Port(
· Начинаем описание портов - порты это как "дырки" в нашем черном ящике, через которые мы подключаем провода.

    clk: in STD_LOGIC; 
· Создаем вход "clk" типа STD_LOGIC - это как провод для тактового сигнала. Тактовый сигнал - это как метроном, который отбивает ритм для всей схемы.

    LED: out STD_LOGIC_VECTOR(7 downto 0) := (others => '1')
· Создаем выход "LED" - это 8 проводов для светодиодов.
· "7 downto 0" означает: бит №7, №6, №5, №4, №3, №2, №1, №0 (всего 8 битов)
· ":= (others => '1')" означает: при включении все светодиоды будут выключены (предполагается, что '1' - светодиод выключен, '0' - включен)

    );
end lr31;
· Закрываем описание портов и заканчиваем описание сущности

architecture arch_lr31 of lr31 is
· Начинаем описание архитектуры - это как "вскрыть черный ящик" и показать, что внутри него находится.

 signal cnt: std_logic_vector(7 downto 0) := (others => '1');
· Создаем внутренний сигнал "cnt" - это как переменная в программировании, но для аппаратуры.
· "7 downto 0" - 8-битный сигнал (как маленькая память на 8 битов)
· ":= (others => '1')" - начинаем со значения "11111111" (все единицы)

 signal freq: std_logic_vector(23 downto 0) := (others => '1');
· Создаем сигнал "freq" - 24-битный счетчик для деления частоты. Он нужен, чтобы считать тактовые импульсы и делать что-то реже.

begin
· Начинаем исполняемую часть - то, что будет реально работать.

  process(clk)
· Создаем процесс, который зависит от сигнала "clk" - процесс это как маленькая программа, которая выполняется когда меняется clk.

  begin
· Начало кода процесса

    if rising_edge(clk) then
· "Если наступил передний фронт тактового импульса" - это момент когда clk меняется с 0 на 1. Как ловить момент, когда метроном щелкает.

  if freq(23) = '1' then
· "Если 23-й бит счетчика freq равен 1" - проверяем, досчитали ли мы до большого числа. 23-й бит становится 1 только когда счетчик насчитает много импульсов.

   cnt <= cnt + 1;
· Увеличиваем счетчик cnt на 1 - переходим к следующему состоянию светодиодов.

   freq(23) <= '0';
· Сбрасываем 23-й бит в 0 - чтобы в следующий раз снова ждать, когда он станет 1.

  else
· Иначе (если 23-й бит еще не стал 1)

   freq <= freq + '1';
· Увеличиваем счетчик freq на 1 - продолжаем считать тактовые импульсы.

  end if;
· Конец условия if-else

 end if;
· Конец условия rising_edge

  end process;
· Конец процесса

  LED <= not std_logic_vector(cnt);
· Подключаем счетчик к светодиодам
· "not" - инвертируем биты (1 становится 0, 0 становится 1)
· Зачем инвертируем? Потому что обычно светодиоды горят когда на них подается 0, а не 1.

end arch_lr31;
· Конец архитектуры

Что делает эта программа?
· Считает тактовые импульсы в freq
· Когда насчитает много (23-й бит станет 1), увеличивает cnt на 1
· cnt выводится на светодиоды, создавая эффект "бегущего огня"

========ПРОЕКТ 2: lr32===============================================================================
=====================================================================================================


entity lr32 is
  Port(
    clk: in STD_LOGIC; 
    LED: out STD_LOGIC_VECTOR(7 downto 0);
    KEY: in STD_LOGIC_VECTOR(2 downto 0)
  );
end lr32;
· Добавился вход KEY - это 3 кнопки: KEY(2), KEY(1), KEY(0)

architecture arch_lr32 of lr32 is
 signal cnt: std_logic_vector(7 downto 0) := (others => '1');
 signal freq: std_logic_vector(23 downto 0) := (others => '1');
 signal state: std_logic := '0';
· signal state - флаг состояния: 0 = ждем нажатия кнопки, 1 = обрабатываем нажатие

 signal key_up, rkey_up: std_logic;
· key_up - запоминает текущее состояние кнопки KEY(0)
· rkey_up - запоминает ПРЕДЫДУЩЕЕ состояние кнопки

begin
· Начало кода

  process(clk)
  begin
 if rising_edge(clk) then
  key_up <= KEY(0);
  rkey_up <= key_up;
 end if;
  end process;
· Этот процесс запоминает состояние кнопки
· key_up <= KEY(0) - запоминаем что кнопка показывает СЕЙЧАС
· rkey_up <= key_up - запоминаем что кнопка показывала на ПРЕДЫДУЩЕМ такте
· Так мы можем обнаружить ИЗМЕНЕНИЕ состояния кнопки

  process(clk)
  begin
 if rising_edge(clk) then
  if state = '0' then
· Если мы в состоянии "ожидание"

    if rkey_up /= key_up then
· "Если предыдущее состояние кнопки не равно текущему" - значит кнопка только что изменилась!

     state <= '1';
· Переходим в состояние "обработка"

     if rkey_up <= '1' then
      cnt <= cnt + 1;
     end if;
· "Если предыдущее состояние было 1" - значит кнопка была отпущена, а теперь нажата
· Увеличиваем счетчик

  else
· Иначе (state = '1' - состояние "обработка")

   freq <= freq + '1';
· Увеличиваем счетчик задержки

   if freq(23) = '1' then
· Если насчитали достаточно времени (прошла задержка)

    state <= '0';
· Возвращаемся в состояние "ожидание"

    freq(23) <= '0';
· Сбрасываем флаг задержки

   end if;
  end if;
 end if;
  end process;
· Конец условий и процесса

  LED <= not std_logic_vector(cnt);
· Выводим счетчик на светодиоды

end arch_lr32;
· Конец

Что делает эта программа?

· Ждет когда кнопка KEY(0) будет нажата
· При нажатии увеличивает счетчик
· Делает задержку чтобы не реагировать на одно нажатие много раз

========ПРОЕКТ 3: lr33===============================================================================
=====================================================================================================


entity lr33 is
  Port(
    clk: in STD_LOGIC; 
    LED: out STD_LOGIC_VECTOR(7 downto 0);
    KEY: in STD_LOGIC_VECTOR(2 downto 0)
  );
end lr33;
· Три кнопки: KEY(0), KEY(1), KEY(2)

architecture arch_lr33 of lr33 is
  signal cnt: std_logic_vector(7 downto 0) := (others => '0');
· Счетчик начинается с 00000000 (все светодиоды горят)

  signal freq: std_logic_vector(25 downto 0) := (others => '0');
· 26-битный счетчик задержки (больше битов - медленнее счет)

  signal state: std_logic := '0';
· Состояние: 0 = ожидание, 1 = обработка

  signal key_prev: std_logic_vector(2 downto 0) := (others => '1');
· Запоминаем предыдущее состояние ВСЕХ трех кнопок

  signal key_pressed: std_logic_vector(2 downto 0) := (others => '0');
· Флаги: какая именно кнопка была нажата

begin
· Начало

  process(clk)
  begin
    if rising_edge(clk) then
· На каждом такте

      key_prev <= KEY(2 downto 0);
· Запоминаем какими кнопки были на предыдущем такте

      if state = '0' then
· Если состояние "ожидание"

        key_pressed <= key_prev and not KEY(2 downto 0);
· Очень важная строка! Определяем какая кнопка нажата:
· key_prev - какими кнопки БЫЛИ (обычно 1 если отпущены)
· not KEY - инвертируем текущее состояние (нажатая кнопка = 0, поэтому not KEY = 1)
· AND - дает 1 только для кнопок которые ИЗМЕНИЛИСЬ с отпущена на нажата

        if key_pressed /= "000" then
· Если хоть одна кнопка нажата (не все флаги равны 0)
state <= '1';
· Переходим в состояние обработки

          if key_pressed(0) = '1' then
            cnt <= cnt + 1;
          end if;
· Если нажата кнопка 0 - увеличиваем счетчик

          if key_pressed(1) = '1' then
            cnt <= cnt - 1;
          end if;
· Если нажата кнопка 1 - уменьшаем счетчик

          if key_pressed(2) = '1' then
            cnt <= (others => '0');
          end if;
· Если нажата кнопка 2 - сбрасываем счетчик в 0

        end if;
· Конец условия нажатия кнопки

      else
· Иначе (state = 1 - состояние "обработка")

        freq <= freq + 1;
· Увеличиваем счетчик задержки

        if freq(25) = '1' then
· Если прошло много времени (25-й бит стал 1)

          if KEY(0) = '0' then
            cnt <= cnt + 1;
          end if;
· Если кнопка 0 все еще нажата - продолжаем увеличивать (удержание)

          if KEY(1) = '0' then
            cnt <= cnt - 1;
          end if;
· Если кнопка 1 все еще нажата - продолжаем уменьшать

        end if;
· Конец условия удержания

        if freq(25) = '1' then
          state <= '0';
          freq <= (others => '0');
          key_pressed <= (others => '0');
        end if;
· Сбрасываем все флаги и возвращаемся в ожидание

      end if;
    end if;
  end process;
· Конец процесса

  LED <= not cnt;
· Выводим счетчик на светодиоды

end arch_lr33;
· Конец

Что делает эта программа?

· KEY(0) - увеличивает счетчик (при удержании продолжает увеличивать)
· KEY(1) - уменьшает счетчик (при удержании продолжает уменьшать)
· KEY(2) - сбрасывает счетчик в 0
· Есть защита от дребезга контактов