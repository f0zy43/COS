========ПРОЕКТ 1: lr21===============================================================================
=====================================================================================================
library IEEE;
· Подключает библиотеку IEEE - стандартную библиотеку для работы с цифровыми схемами в VHDL

use IEEE.STD_LOGIC_1164.ALL;
· Использует пакет STD_LOGIC_1164 - добавляет основные типы данных (STD_LOGIC, STD_LOGIC_VECTOR) для работы с цифровыми сигналами

use IEEE.STD_LOGIC_ARITH.ALL;
· Использует пакет STD_LOGIC_ARITH - добавляет арифметические операции для сигналов

use IEEE.STD_LOGIC_UNSIGNED.ALL;
· Использует пакет STD_LOGIC_UNSIGNED - позволяет работать с сигналами как с беззнаковыми числами

entity lr21 is
· Объявляет сущность (модуль) с именем lr21 - создает "черный ящик" с входами и выходами

Port(
· Начинает раздел портов - перечисление всех входов и выходов модуля

    KEY_G1: in STD_LOGIC;
· Объявляет вход KEY_G1 - это один бит (STD_LOGIC), представляет собой кнопку G1

    KEY_V1: in STD_LOGIC;
· Объявляет вход KEY_V1 - еще одна кнопка V1

    KEY_G2: in STD_LOGIC;
    KEY_V2: in STD_LOGIC;
    KEY_G3: in STD_LOGIC;
    KEY_V3: in STD_LOGIC;
· Объявляет остальные кнопки - всего 6 кнопок: G1, V1, G2, V2, G3, V3

    LED: out STD_LOGIC_VECTOR(7 downto 0)
· Объявляет выход LED - это 8-битный вектор (7 downto 0 означает биты 7,6,5,4,3,2,1,0) для управления 8 светодиодами

end lr21;
· Завершает объявление сущности

architecture arch_lr21 of lr21 is
· Начинает архитектуру модуля - описывает внутреннее поведение модуля lr21

    signal led_temp : STD_LOGIC_VECTOR(7 downto 0) := (others => '1');
· Объявляет внутренний сигнал led_temp - временная переменная для хранения состояния светодиодов
· := (others => '1') - инициализирует все биты значением '1' (светодиоды выключены)

begin
· Начинает исполняемую часть архитектуры

    process(KEY_G1, KEY_G2, KEY_G3, KEY_V1, KEY_V2, KEY_V3)
· Создает процесс - блок кода, который выполняется при изменении любого из перечисленных сигналов
· Чувствительность к кнопкам - процесс запускается когда меняется состояние любой кнопки

    begin
· Начинает тело процесса

        led_temp <= (others => '1');
· По умолчанию выключает все светодиоды - присваивает всем битам '1'
· Выполняется в начале каждого запуска процесса

        if KEY_G1 = '0' and KEY_V1 = '0' then
· Проверяет условие: если кнопка G1 нажата (='0') И кнопка V1 нажата (='0')

            led_temp <= "01111111";
· Включает определенные светодиоды - бит 7 = '0' (горит), остальные = '1' (не горят)

        elsif KEY_G1 = '0' and KEY_V2 = '0'  then
· Иначе если нажаты G1 и V2

            led_temp <= "00111111";
· Включает светодиоды - биты 7 и 6 = '0' (горят)

        elsif KEY_G1 = '0' and KEY_V3 = '0' then
            led_temp <= "00011111";
· Иначе если нажаты G1 и V3, включает биты 7,6,5

        end if;
· Завершает блок условий для G1

        if KEY_G2 = '0' and KEY_V1 = '0' then
            led_temp <= "00001111";
· Новый блок условий для G2 - если нажаты G2 и V1, включает биты 7,6,5,4

        elsif KEY_G2 = '0' and KEY_V2 = '0' then
            led_temp <= "00000111";
· Если нажаты G2 и V2, включает биты 7,6,5,4,3

        elsif KEY_G2 = '0' and KEY_V3 = '0' then
            led_temp <= "00000011";
· Если нажаты G2 и V3, включает биты 7,6,5,4,3,2

        end if;
· Завершает блок условий для G2

        if KEY_G3 = '0' and KEY_V1 = '0' then
            led_temp <= "00000001";
· Блок условий для G3 - если нажаты G3 и V1, включает только бит 7

        elsif KEY_G3 = '0' and KEY_V2 = '0' then
            led_temp <= "00000000";
· Если нажаты G3 и V2, включает ВСЕ светодиоды (все биты = '0')

        end if;
· Завершает блок условий для G3

    end process;
· Завершает процесс

    LED <= led_temp;
· Присваивает выходу LED значение из временного сигнала - связывает внутренний сигнал с выходом модуля

end arch_lr21;
· Завершает архитектуру

========ПРОЕКТ 2: lr22===============================================================================
=====================================================================================================

entity lr22 is
· Объявляет сущность lr22

  Port(
    clk: in STD_LOGIC;
· Добавляет вход clk - тактовый сигнал (импульсы для синхронизации)

    LED: out STD_LOGIC_VECTOR(7 downto 0) := (others => '1')
· Выход LED с инициализацией - сразу при включении все светодиоды выключены

  );
end lr22;
· Завершает объявление портов и сущности

architecture arch_lr22 of lr22 is
· Начинает архитектуру

 signal cnt: INTEGER range 0 to 50000000 := 0;
· Создает сигнал-счетчик cnt - целое число от 0 до 50 миллионов, начинается с 0
· Нужен для отсчета времени - будет считать тактовые импульсы

 signal led_state: STD_LOGIC := '1';
· Сигнал для состояния светодиода - '1' = выключен, '0' = включен

begin
· Начало исполняемой части

  process(clk)
· Создает процесс, чувствительный к тактовому сигналу - выполняется на каждом такте

  begin
    if rising_edge(clk) then
· Проверяет фронт тактового сигнала - условие выполняется только в момент перехода clk из '0' в '1'

  if cnt < 50000000 then
· Проверяет: если счетчик меньше 50 миллионов

   cnt <= cnt + 1;
· Увеличивает счетчик на 1

  else
· Иначе (если счетчик достиг 50 миллионов)

   cnt <= 0;
· Сбрасывает счетчик в 0

   led_state <= not led_state;
· Инвертирует состояние светодиода - если был '1' становится '0', и наоборот

  end if;
· Конец условия if-else

 end if;
· Конец условия rising_edge

  end process;
· Конец процесса

  LED(0) <= led_state;
· Присваивает нулевому светодиоду значение led_state - только первый светодиод мигает

end arch_lr22;
· Конец архитектуры

========ПРОЕКТ 3: lr23===============================================================================
=====================================================================================================

use IEEE.NUMERIC_STD.ALL;
· Использует пакет NUMERIC_STD - для арифметических операций с числами

  Port(
    clk: in STD_LOGIC;
    button: in STD_LOGIC_VECTOR(2 downto 0);
· Вход button как вектор - 3 кнопки (биты 2,1,0) в одном сигнале

architecture arch_lr23 of lr23 is
· Начало архитектуры

  signal cnt: INTEGER range 0 to 50000000 := 0;
· Счетчик для отсчета времени

  signal led_state: STD_LOGIC := '0';
· Состояние светодиода (начало с '0' - включен)

  signal any_button_pressed: STD_LOGIC;
· Сигнал-флаг: '1' если нажата любая кнопка

  signal debounced_button: STD_LOGIC_VECTOR(2 downto 0) := "111";
· Сигнал для "очищенных" от дребезга кнопок - начинается с "111" (все отпущены)

  signal lfsr: STD_LOGIC_VECTOR(7 downto 0) := "10101010";
· LFSR (регистр сдвига) - генерирует псевдослучайные числа, начальное значение 10101010

  signal rand_idx1: INTEGER range 0 to 7 := 0;
· Первый случайный индекс светодиода (0-7)

  signal rand_idx2: INTEGER range 0 to 7 := 0;
· Второй случайный индекс светодиода

  signal led_temp: STD_LOGIC_VECTOR(7 downto 0) := (others => '1');
· Временный сигнал для светодиодов

  signal prev_any_button_pressed: STD_LOGIC := '0';
· Предыдущее состояние кнопки - для обнаружения нажатия

  debounced_button <= button;
· Прямое присваивание - кнопки без антидребезга (просто копирование)

  any_button_pressed <= '0' when debounced_button = "111" else '1';
· Логическое условие: если все кнопки отпущены ("111"), то флаг = '0', иначе = '1'

  process(clk)
  begin
    if rising_edge(clk) then
      lfsr <= lfsr(6 downto 0) & (lfsr(7) XOR lfsr(5) XOR lfsr(4) XOR lfsr(3));
    end if;
  end process;
· LFSR процесс: на каждом такте сдвигает биты и вычисляет новый бит через XOR
· Генерирует случайную последовательность

  process(clk)
  begin
    if rising_edge(clk) then
      prev_any_button_pressed <= any_button_pressed;
· Запоминает предыдущее состояние кнопки

      if any_button_pressed = '1' and prev_any_button_pressed = '0' then
· Обнаруживает фронт нажатия - кнопка только что нажата

        rand_idx1 <= to_integer(unsigned(lfsr(2 downto 0))) mod 8;
· Берет младшие 3 бита LFSR и преобразует в число 0-7 - первый случайный индекс

        rand_idx2 <= (to_integer(unsigned(lfsr(5 downto 3))) + 1) mod 8;
· Берет следующие 3 бита LFSR, добавляет 1 и берет по модулю 8 - второй индекс

        if rand_idx2 = rand_idx1 then
          rand_idx2 <= (rand_idx2 + 1) mod 8;
        end if;
· Гарантирует, что индексы разные - если совпали, сдвигает второй индекс

  process(clk)
  begin
    if rising_edge(clk) then
      if any_button_pressed = '1' then
· Если кнопка нажата - работает мигание

        if cnt < 50000000 then
          cnt <= cnt + 1;
        else
          cnt <= 0;
          led_state <= not led_state;
        end if;
· Счетчик для мигания (аналогично проекту 2)

      else
        led_state <= '1';
        cnt <= 0;
      end if;
· Если кнопка отпущена - выключает светодиод и сбрасывает счетчик

  process(any_button_pressed, led_state, rand_idx1, rand_idx2)
· Процесс для управления светодиодами - запускается при изменении этих сигналов

  begin
    led_temp <= (others => '1');
· По умолчанию все светодиоды выключены

    if any_button_pressed = '1' then
      led_temp(rand_idx1) <= led_state;
      led_temp(rand_idx2) <= led_state;
    end if;
· Если кнопка нажата - включает два случайных светодиода в режиме мигания

  LED <= led_temp;
· Вывод на светодиоды